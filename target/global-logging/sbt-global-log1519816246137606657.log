[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/R%C3%A9mi/Desktop/Efrei%20Paris/M2/Scala%20Programming/repo_project/Scala_Project/src/main/scala/main.scala","languageId":"scala","version":1,"text":"import scala.io.Source\nimport scala.util.{Success, Failure}\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport reactivemongo.api.{ Cursor, DB, MongoConnection, AsyncDriver }\nimport reactivemongo.api.MongoConnection.ParsedURI\nimport reactivemongo.api.bson.{ BSONDocument,BSONDocumentWriter, BSONDocumentReader, Macros,document}\nimport reactivemongo.api.bson.collection.BSONCollection\nimport Model._\nimport Reader._\nimport reactivemongo.api.commands.Command\nobject MainApp extends App{\n  val mongoURL = \"mongodb://localhost:27018\"\n  val dbName= \"scala\"\n  val mongoDriver = AsyncDriver()\n  val parsedURIFuture: Future[ParsedURI] = MongoConnection.fromString(mongoURL)\n  val connection: Future[MongoConnection] = parsedURIFuture.flatMap(u => mongoDriver.connect(u))\n  val db: Future[DB] = connection.flatMap(_.database(dbName))\n  val countriesCollection: Future[BSONCollection] = db.map(_.collection(\"countries\"))\n  val airportsCollection: Future[BSONCollection] = db.map(_.collection(\"airports\"))\n\n  implicit def countryReader: BSONDocumentReader[Country] = Macros.reader[Country]\n\n  // def findCountry(name: String): Future[List[Country]] =\n  //   countriesCollection.flatMap(_.find(BSONDocument(\"continent\" -> name)).cursor[Country]()\n  //   //.collect())\n  //   .collect[List](250, Cursor.FailOnError[List[Country]]()))\n  // val countries= findCountry(\"EU\")\n\n  val hnabc = highest_number_of_airports(airportsCollection)\n\n  countries.onComplete({\n    case Success(listCountry) => {\n      //Do something with my list\n      println(listCountry)\n    }\n    case Failure(e) => {\n      //Do something with my error\n      print(\"error\")\n    }\n  })\n\n  hnabc.onComplete({\n    case Success(listCountry) => {\n      //Do something with my list\n      println(listCountry)\n    }\n    case Failure(e) => {\n      //Do something with my error\n      print(\"error\")\n    }\n  })\n\n\n\n\n\n\n\n\n\n\n\n\n\n  // reader.parser(\"src/main/scala/file.csv\",reader.Point.csvtoP)\n  // // you can also use the Java Scanner class, if desired\n  // val scanner = new java.util.Scanner(System.in)\n  // print(\"Queries or Reports?\")\n  // val input = scanner.nextLine()\n  // if (input==\"Queries\" || input==\"Reports\"){\n  //   print(s\"You choose $input\\n\")\n  // } else { print(s\"You choose poorly\")}\n  // scanner.close();\n  \n  //Pour le projet tout doit Ãªtre sur github, chacun partage\n  //le parsing prend en param une fonction avec des points en 2D ou 3D\n  //lire au moins le fichier, trouver le fichier, le charger\n  //collection [string] => Option[P] ou Try[P] (mauvais pour la perf) ou Either[Int/String, P] (signature deserialization) \n  //Either code d'erreur\n  //def t[P](file:String, f : function de type P) : collection[P]  fonction d'ordre supÃ©rieur\n  //Point (x :Int, y:Int, z:Option[Int])\n  //deserializer dans le companion object d'une case class\n  //must to do : deserialize\n  //reactive mongo +mongodb\n  //docker image\n  //faire unmodel pour chacun des type mÃ©tier\n  // val l=List((2, \"ook!\"), (1, \"lolcode\"), (3, \"intercal\"), (5, \"ook ook\"), (1, \"brainfuck\"), (2, \"ArnoldC\"))\n  // val bibli=List(List(\"ook!\",\"ook ook\"),List(\"lolcode\"),List(\"intercal\"),List(\"brainfuck\"),List(\"ArnoldC\"))\n\n  // def count_vote(list:List[(Int, String)],bibli:List[List[String]]): List[(Object,Int)] = {\n  //   list.map(x=> if (bibli.exists(_.contains(x._2))) ( x._1 , bibli.filter(_.contains(x._2))(0)(0) ) else (x._1,None))\n  //   .groupBy(_._2).map { \n  //     case (key,value) => key -> (value.map(_._1)).sum}.toList\n  //   }\n  //println(count_vote(l,bibli))\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\RÃ©mi\Desktop\Efrei Paris\M2\Scala Programming\repo_project\Scala_Project\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 2 s, completed 7 fÃ©vr. 2022 14:17:17[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/R%C3%A9mi/Desktop/Efrei%20Paris/M2/Scala%20Programming/repo_project/Scala_Project/src/main/scala/Reports.scala","languageId":"scala","version":1,"text":"import scala.concurrent.Future\r\nimport scala.concurrent.ExecutionContext.Implicits.global\r\n\r\nimport reactivemongo.api.bson.{ BSONDocument, BSONString }\r\n\r\nimport reactivemongo.api.Cursor\r\nimport reactivemongo.api.bson.collection.BSONCollection\r\nimport reactivemongo.api.commands.AggregationFramework\r\nimport Model._\r\n\r\nobject Reports{\r\n    def highest_number_of_airports(col:Future[BSONCollection],n:Int =10): Future[List[Airport]] = {\r\n        col.aggregatorContext[BSONDocument](\r\n        pipeline = List(\r\n            Group(BSONString(\"$iso_country\"))( \"total\" -> Sum(1)),\r\n            )).prepared.cursor.collect[List]()\r\n    }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/R%C3%A9mi/Desktop/Efrei%20Paris/M2/Scala%20Programming/repo_project/Scala_Project/src/main/scala/reader.scala","languageId":"scala","version":1,"text":"import scala.io.Source\r\nobject Reader {\r\n    def parser[P](str: String, csvtoP : Array[String] => Option[P]): /*Iterator[P]*/Any = {\r\n        Source.fromFile(str)\r\n        .getLines()\r\n        .map(_.split(\",\"))\r\n        .flatMap(Point.csvtoP)\r\n    }\r\n    case class Point(x:Int, y: Int, z: Option[Int] = None)\r\n    //case class = plusieurs mÃ©thodes prÃ©dÃ©fini\r\n    object Point {\r\n        def csvtoP(str:Array[String]) : Option[Any] = Option(str)\r\n        .map{_.map(_.trim)\r\n        .map(x => util.Try(x.toInt).toOption) match {\r\n            case Array(Some(x),Some(y)) => Some(Point(x.toInt, y.toInt))\r\n            case Array(Some(x),Some(y),Some(z)) => Some(Point(x.toInt, y.toInt,Some(z.toInt)))\r\n            case _ =>None\r\n            }\r\n        }\r\n    }\r\n}"}})[0m
